# Meltdown实验报告
## 顾健鑫 PB16060130
### 1. 实验原理
- 本次实验采用的是meltdown论文中介绍的利用一个256*4096的试探数组以flush+reload的形式来得出要攻击地址的数据
- 实现攻击的汇编代码如下所示

         "movzx (%[addr]), %%eax\n\t" 
         "shl $12, %%rax\n\t"
         "movzx (%[probe_array], %%rax, 1), %%rbx\n"
         
- 汇编代码中的第一行为一个制造异常的指令，在论文中称其为trasient instruction。由于处理器在处理异常时会先预执行接下来的指令，导致接下来的访存指令会使得对应的块被掉入cache，再通过一定的判断方式，便可以将内存地址中的数据获取出来。
### 2. 攻击过程
1. 初始化设置，其中包括全局变量cache访问阙值，在访存时间小于该值时认为访存的地址对应的块位于cache中，还有异常信号的处理以及CPU的相关设置（这两个设置函数取自注释中的地址中的代码）
2. 准备一个大小为256*4KB的数组作为试探数组，这里认为一个页大小为4KB，这样试探数组中的256项就与一个字节对应的数据有一一对应关系，在运行上述汇编代码后对整个数组进行遍历，读取速度快的那一块的编号就对应要攻击的地址中的数据。
3. 每攻击一个地址前，通过flush\_probe\_array()函数来将试探数组从cache中调离，保证在攻击时只有我们想要的数据对应的编号的块进入了cache。
4. 执行上述汇编指令
5. 对试探数组进行遍历操作，对访问时间小于cache访问时间阙值的进行统计。由于上述的汇编指令不能保证每次都能有效的把想要地址对应的块放入cache，因此我们需要多次进行相同的操作，并认为试探数组中访问时间小于阙值的次数最多的那一块为我们想要的数据。每一次的遍历访问由reload()函数实现。
6. 通过readbyte()函数多次调用flush\_probe\_array()，probe()以及reload()函数，此处设置为1000次。并最终找出小于阙值次数最多的块，返回其编号。该编号即为要攻击的地址中的数据值。
### 3.输出信息
-  程序理应输出信息如图一所示，但由于时间相对有限，debug工作未完成，和图二（我自己的程序的输出结果）对比可以看到，我的程序在输出最终判断的要攻击地址的数据时有错误出现。初步定位为两个地方的问题，set\_cache\_hit\_time()函数有问题导致阙值设置错误或者是在多次试探并计数时有错误，导致统计结果都为‘1’。
### 4. 程序运行过程
    $ make
    $ ./meltdown.sh 
- 上述脚本引用自 <https://gitee.com/idea4good/meltdown/blob/master/>
### 5. 参考文献与代码
- <https://gitee.com/idea4good/meltdown/blob/master/meltdown.c>
- <https://github.com/paboldin/meltdown-exploit>
- 